<!doctype html public "-//w3c//dtd html 4.0 transitional//en">

<html>

<head>

   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">

   <meta name="GENERATOR" content="Mozilla/4.6 [en] (Win98; I) [Netscape]">

   <title>Interfacing with the system</title>

</head>

<body>



<table BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%" >

<tr>

<th ALIGN=CENTER COLSPAN="3">Z88 Developers' Notes</th>

</tr>

<tr>

<td ALIGN=LEFT VALIGN=BOTTOM WIDTH="10%"><a href="applovw.htm">Previous</a></td>

<td ALIGN=CENTER VALIGN=BOTTOM WIDTH="80%"><a href="index.htm">Contents</a></td>

<td ALIGN=RIGHT VALIGN=BOTTOM WIDTH="10%"><a href="aplstrct.htm">Next</a></td>

</tr>

</table>

<hr WIDTH="100%">

<p>



<b><font size=+1>3. Interfacing with the system</font></b>

<p>The application program interfaces with the system in two ways. An application

consists of both an application header and a main body. The header sets

up various parameters for the application such as whether it is good or

bad, and also contains all the menus and help text. Each menu command generates

a key code, so that the application itself just receives a code when a

command is generated, either by the menu or the key sequence. This obviously

reduces the application's overheads somewhat. The body of the application

interfaces with the system via calls. Most of the main system calls are

entered using a RST $20 instruction, the floating point routines being

the exception, followed by one or two bytes which define the required function.

A full list is given in 'System Calls Reference'. For example the code

to write a character to standard output (called <a href='osout.htm'>OS_Out</a>) would be called

as follows:

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RST&nbsp; $20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Z80 restart instruction

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEFB <a href='osout.htm'>OS_Out</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; reason code</pre>

In the text we will write something like this:

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL_OZ(<a href='osout.htm'>OS_Out</a>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; write a character</pre>

as though a macro called 'CALL_OZ' exists to generate the calls. A macro

is to be recommended for automatic generation of the one and two byte codes.

However it is written this code sends the character whose ASCII value is

in A to the screen. This format of operating system call has the merit

of economy of space; one byte for the RST instruction, one byte for the

appended function code. The system call can easily find the appended byte

using the return address pushed by the RST instruction and adjust the return

address to point after it. A scheme in which the function code was loaded

into a register before executing RST $20 would waste an extra byte every

time the function is called.

<p>Note: As you may have already noted from the above, we represent hexadecimal

numbers by preceding them with a '$' symbol. Occasionally where hexadecimal

is unambiguously the base the '$' is omitted. The '@' symbol is used in

prefix fashion to indicate binary numbers. The mnemonic names for the calls

are prefixed by either 'GN', 'OS', 'DC' or 'FP'. This represents a rather

arbitrary division into:

<pre>'GN_'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; General utilities like arithmetic routines and data type

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; conversion.



'OS_'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Operating System calls like process management and error handling.



'DC_'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Director/CLI calls are very low level, for which an alternative

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'OS' or 'GN' call usually provides a more convenient interface.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Director is a synonym for Index. CLI stands for Command Line

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Interpreter.



'FP_'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Floating point calls access the internal floating point package.</pre>

When one wishes to find the system call to perform a particular action,

turn to the 'System Calls Finder,' This lists various actions the user

may want to perform, and refers to the appropriate system calls whose specification

may be found in 'System Calls Reference'.

<br>&nbsp;

<p><b>Notation</b>

<p>We now introduce the notation that will be adopted in presenting the

interface specifications of the various calls. Uppercase register letters

(A,HL etc.) represent the main register set; lower case letters (a,hl etc.)

represent the alternate set, as distinct from the more usual notation A',H'L'

etc. The alternate register set is used freely within the operating system

and so almost every call is specified as corrupting all the alternate registers.

For this reason the changes to the alternate set are not mentioned in most

call specifications. Changes to registers are indicated as follows. Here

F, HL, and IX may have been corrupted and the other registers remain intact:

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A.BCDE../..IY same

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .F....HL/IX.. different</pre>

The IY register is never affected or used as a parameter by system calls.

IX, however, is used as a handle reference for many I/O calls. IY may therefore

be used as a base register of some sort, eg. pointing at the base address

of an application's workspace.

<p>The stack pointer, as one might expect, will never change; this is not

indicated explicitly. The above provides a succinct and clear notation

which will be used throughout the subsequent sections, particularly 'System

Calls Reference.' Where the value of input parameters is referred to in

explaining the value of output values the input parameter will be postfixed

(in), eg. DE(in). One other notational point worth mentioning is that Fz

represents the zero flag, Fc the carry flag, etc.

<br>&nbsp;

<p><b>Other terminology</b>

<p>As outlined above the 'physical address space' (by this we mean what

is actually there ie. addressable RAM chips) is divided into 256 banks

of 16K. The 64K 'logical address space' (by which we mean what the Z80

can actually see at any one time) is divided into 4 segments of 16K. Each

segment can be 'bound' to any bank. Being bound means that when the Z80

looks at that segment, the bank it is bound to is what it actually sees.

The segments are numbered 0 to 3 as follows:

<pre><i>Segment</i>&nbsp;&nbsp;&nbsp;&nbsp; <i>Logical address</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>Used as

</i>0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $0000 - $1FFF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RST 00H-38H, sys.vars, stack, appl. worksp.

0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $2000 - $3FFF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8K RAM (contigous RAM or application bank)

1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $4000 - $7FFF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Application code or RAM allocation

2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $8000 - $BFFF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Application code or RAM allocation

3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $C000 - $FFFF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Application code (ROM/EPROM) or RAM</pre>

The banks are mapped onto the following physical memory sources in the

machine:

<pre><i>Banks</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>Wired to

</i>$00 to $1F&nbsp; 128K ROM, wired to slot 0 (512K range)

$20 to $3F&nbsp; :RAM.0 (32K), wired to slot 0 (512K range)

$40 to $7F&nbsp; wired to slot 1 (1MB range)

$80 to $BF&nbsp; wired to slot 2 (1MB range)

$C0 to $FF&nbsp; wired to slot 3 (1MB range)</pre>

Note that most cards and the internal memory, do not exploit the full lMB

addressing range, but only decode the lower address lines. This means that

memory will appear more than once within the lMB range. The memory of a

32K card in slot 1 would appear at banks $40 and $41, $42 and $43, ...,

$7E and $7F. Alternatively a 128K EPROM in slot 3 would appear at $C0 to

$C7, $C8 to $CF, ..., $F8 to $FF. This way of addressing is assumed by

the system - so you can rely on it too - and should be followed by anyone

producing card hardware for the Z88. Note that the lowest and highest bank

in an EPROM can always be addressed by looking at the bank at the bottom

of the 1MB address range and the bank at the top respectively.

<p>Slot 0 hardware is differently wired than slot 1 to 3. The lower half

of the 1MB address range (512K) is reserved for ROM (however the Z88 mother

board has only tracked the address line for 128K, but may be extended with

the missing address lines). The upper half is reserved for RAM. Currently

32K is installed, but pins are allocated for a 128K RAM chip. The hardware

can address 512K RAM, but address line has to be added explicitly (circuitry

is only tracked for 128K RAM).

<p>System calls exist to allow you to bind any bank to any segment, and

should always be used, rather than resorting to hardware, because the system

has to keep track of your binding state. When system calls are made the

bindings will change and need to be restored before control is returned

your application. Segment 0 operates slightly differently to the other

segments because the Z80 needs special information at the lower addresses

of its logical address space. The lower 8K of segment 0 can either be ROM,

for hard reset, or RAM, for restart routines and other OZ information.

Bindings made on segment 0 affect only the upper 8K, and so involve paging

in an 8K half bank, not a full 16K bank. The lowest bit of the bank number,

which is normally an 8 bit value, is used to select whether the lower (least

significant bit = 0) or upper (least significant bit = l) is bound to the

half segment. The least significant bit of the bank number, therefore,

no longer refers to which bank is to be used and so for the purposes of

choosing a bank it is regarded as zero. The upshot of all this is that

only even numbered banks can be bound into the upper 8K of segment zero,

with the half of the bank being selected by looking at the lowest bit of

what is nominally the bank number.

<p>The term 'extended address' is used throughout the text to refer to

the combination of an offset in a bank and a bank number. An extended address

is often passed in a register trio such as BHL or CDE. In these cases B

(or C) will hold the bank number and the lower 14 bits of HL (or DE) will

hold the offset within the bank. Often B register being zero indicates

that HL should be used directly as a logical address, but there are exceptions

to this. The remaining upper 2 bits of HL may be used as 'memory mask'.

The memory mask is a technique for making the bank binding a bit easier.

If you know which segment you want the memory you are looking at to be

bound to, and you tell the memory allocator, then it will return an extended

address in BHL with the top 2 bits of HL set to your intended segment number.

The result of this is when the bank is bound in to the segment you said

it would be, you can use HL to address it, as HL will reflect the logical

address of the bound in memory.

<p>When system calls expect local pointers to information it is vital that

this information is kept with the current bank boundary. System calls keep

track of the source bank of the pointer but does not expect it to cross

bank boundaries. The end result of this is random. <a href='gnsop.htm'>GN_Sop</a> (write string

to std. output) for example just displays rubbish from the point of the

bank boundary onwards.

<p>

<hr WIDTH="100%">

<table BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%">

<tr>

<td ALIGN=LEFT VALIGN=TOP WIDTH="33%"><a href="applovw.htm">Previous</a></td>

<td ALIGN=CENTER VALIGN=TOP WIDTH="34%"><a href="index.htm">Contents</a></td>

<td ALIGN=RIGHT VALIGN=TOP WIDTH="33%"><a href="aplstrct.htm">Next</a></td>

</tr>

<tr>

<td ALIGN=LEFT VALIGN=TOP WIDTH="33%">Application Writing</td>

<td ALIGN=CENTER VALIGN=TOP WIDTH="34%">Interfacing with the system</td>

<td ALIGN=RIGHT VALIGN=TOP WIDTH="33%">Application Static Structures</td>

</tr>

</table>

</body>

</html>


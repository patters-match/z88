<!doctype html public "-//w3c//dtd html 4.0 transitional//en">

<html>

<head>

   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">

   <meta name="GENERATOR" content="Notepad">

   <title>Output and the screen driver</title>

</head>

<body>

<table BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%" >

<tr>

<th ALIGN=CENTER COLSPAN="3">Z88 Developers' Notes</th>

</tr>

<tr>

<td ALIGN=LEFT VALIGN=BOTTOM WIDTH="10%"><a href="memmanag.htm">Previous</a></td>

<td ALIGN=CENTER VALIGN=BOTTOM WIDTH="80%"><a href="index.htm">Contents</a></td>

<td ALIGN=RIGHT VALIGN=BOTTOM WIDTH="10%"><a href="fileio.htm">Next</a></td>

</tr>

</table>



<hr WIDTH="100%">

<p>



<b><font size=+1>7. Output and the screen driver</font></b>

<br>&nbsp;<p>



<A NAME="output">

<b>Output</b><p>



Output to the screen can be achieved by treating the screen as a device

and using the file I/O system calls. However, there are four calls which

can be used to send output to what is called standard output, which although

it may be redefined by the CLI, see 'Standard I/O and the CLI', is usually

the screen device. The four calls are:



<pre>

            <a href='osout.htm'>OS_Out</a>      write character to standard output

            <a href='gnnln.htm'>GN_Nln</a>      write newline to standard output (&lt;CR>&lt;LF>)

            <a href='gnsop.htm'>GN_Sop</a>      write a string in local memory to standard output

            <a href='gnsoe.htm'>GN_Soe</a>      as <a href='gnsop.htm'>GN_Sop</a>, but from an extended address

</pre>



These calls are fairly friendly as far as register corruption is concerned.

<a href='osout.htm'>OS_Out</a> writes the character held in register A and forces Fc = 0 before

returning with no other register or flag changes. <a href='gnnln.htm'>GN_Nln</a> changes no registers

and returns Fc = 0 unless there is an error. <a href='gnsop.htm'>GN_Sop</a> and <a href='gnsoe.htm'>GN_Soe</a> expect HL

(or BHL) to point to a null-terminated string, and on exit HL (or BHL)

will point to the null, with other registers remaining the same, unless

there is an error. Errors can occur if the standard output device has been

redirected to somewhere other than the screen. In the case of errors Fc

= 1 and register A will contain an error code. If you are not doing any

redirection yourself then these kind of error situations can be largely

ignored, since if the user is doing bizarre stream rebindings it is not

your responsibility what happens. Examples of these routines in use can

be seen in the "Input and the keyboard decoder" section.

<p>In using the Z88 you may well have come across a "Page Wait" message

which appears on the left hand side of the screen in place of the application

name and list of topics. This message can be generated by an application

(it is not done automatically) when scrolling output is being sent to the

screen. The actual system call involved is <a href='ossr.htm'>OS_Sr</a> with register A = SR_PWT.

This call produces the "Page Wait" message, waits for a key, restores the

application name and topic list and then returns to the application. Because

at the core of this routine there is a keyread, application writers must

be careful to check for pre-emption codes, especially RC_QUIT. Although

the writer may think about "Page Wait" as primarily an output function,

it has all the characteristics of an input function. However, it only returns

&lt;BACKSPACE> (ASCII 8) and all relevant error codes like RC_QUIT and

RC_DRAW.

<br>&nbsp;<p>



<A NAME="scrdrv">

<b>The screen driver</b><p>



The Z88 incorporates a comprehensive screen driver, so that apart from

printing normal characters, the user may, by sending suitable control codes

to the screen:



<pre>

            Set fonts and select bold or flash effects for characters;

            Switch the cursor on and off;

            Simulate the effects of special keys (Caps lock, index etc.)

            Define, select and scroll windows;

            Select the horisontal and vertical print positions;

            Set justification or alignment;

            Set up user defined characters;

            Make various strings of beeps

</pre>



in fact, any graphic effects used by the built-in software with the single

exception of the map. This is accessed more directly through the system

calls, in particular <a href='osmap.htm'>OS_Map</a> described in "Miscellaneous useful routines".

InterLogic have also supplied utilities to plot, draw lines and sprites

in the map area, which easily can be linked with application code using

the Z80 Module Assembler.

<p>



<A NAME="ctrlchar">

<b>Direct Control Characters</b><p>



The following standard control characters have a special effect:



<pre>

<i>ASCII name</i>  <i>Value</i>       <i>Z88 effect</i>

NUL         $00         Ignored (Possibly used by the system for control of screen restoring.)

SOH         $01         Escape character for screen driver <!--ENQ         $05         Escape character for printer filter-->

BEL         $07         Make a beep

BS          $08         Move Cursor Left

HT          $09         Move Cursor Right

LF          $0A         Move Cursor Down

VT          $0B         Move Cursor Up

FF          $0C         Clear screen (current window)

DEL         $7F         Draw black box, (currently, undefined codes do too)

</pre>



<A NAME="escseq">

<b>Escape Sequences</b><p>



The characters SOH ($01) is used as an escape character to prefix the special

character combinations. It may be followed either by a single special character,

or if more than one parameter is to follow, by a count byte which specifies

the number of following parameters - this may be in the form of a binary

number with the top bit set, ie. count plus 128, or an ASCII code for a

single decimal digit - clearly the latter is impossible for a count of

more than 9. Thus the following sequences are equivalent - both move the

cursor to character position (x,y):

<p>1, '3', '@', 32+x, 32+y 1, 128+3, '@', 32+x, 32+y

<p>NOTE: A character in single quotes is used in this section as a concise

notation for a character constant, so for instance 'A' is the ASCII code

for A, ie. $41 or 65 decimal. This translates into rather less elegant

ASC"A" when used in BBC BASIC or its assembler, so to send the former of

the above sequences to the screen from BBC BASIC one might do:

<p>x=3: y=4 VDU 1,ASC"3", ASC"@", 32+x,32+y<p>



<A NAME="specchar">

<b>Special Characters</b><p>



The following screen driver codes generate special printable characters

when preceeded by SOH:



<pre>

<i>Code</i>        <i>Value</i>       <i>Description</i>             <i>Width</i>       <i>Boldable</i>

' '         $20         Exact symbol            1

'!'         $21         Bell symbol             3

'''         $27         Grave accent            1           yes

'*'         $2A         Square                  1           yes

'+'         $2B         Diamond                 1           yes

'-'         $2D         SHIFT symbol            3

'|'         $7D         Vertical unbroken bar   1           yes

SD_SPC      $E0         SPACE symbol            3

SD_ENT      $E1         ENTER symbol            3

SD_TAB      $E2         TAB symbol              3

SD_DEL      $E3         DEL symbol              3

SD_ESC      $E4         ESC symbol              3

SD_MNU      $E5         MENU symbol             3

SD_INX      $E6         INDEX symbol            3

SD_HLP      $E7         HELP symbol             3

SD_OLFT     $F0         Outline arrow Left      2

SD_ORGT     $F1         Outline arrow Right     2

SD_ODWN     $F2         Outline arrow Down      2

SD_OUP      $F3         Outline arrow Up        2

SD_BLFT     $F4         Bullet arrow Left       1

SD_BRGT     $F5         Bullet arrow Right      1

SD_BDWN     $F6         Bullet arrow Down       1

SD_BUP      $F7         Bullet arrow Up         1

SD_PLFT     $F8         Pointer arrow Left      1           yes

SD_PRGT     $F9         Pointer arrow Right     1           yes

SD_PDWN     $FA         Pointer arrow Down      1           yes

SD_PUP      $FB         Pointer arrow Up        1           yes

</pre>



<A NAME="boxchars">

<b>Box Characters</b><p>



1, '2', '*', &lt;char>

<p>(where &lt;char> is from 'A' to 'O') draws various character such as

arrows or box construction shapes (which are all boldable), with the following

logic:

<p>Each of the bottom 4 bits of 'char' represents a direction:



<pre>

bit 0       decimal 1   Left

bit 1       decimal 2   Down

bit 2       decimal 4   Right

bit 3       decimal 8   Up

</pre>



If one bit is set, a pointer arrow in the relevant direction is drawn.

If two bits are set, two sides of a square or a line will be drawn. If three bits

are set, a 'T' shape will be drawn. If all four bits are set, a cross will

be drawn.

<p>For example, the corner generated: VDU 1, ASC"2", ASC"*", ASC"F" 

makes a reasonable logical NOT sign.

<br>&nbsp;



<pre>

Code			Up	Left	Down	Right	Symbol



1, '2', '*', 'A'	0	0	0	1	Pointer arrow Right

1, '2', '*', 'B'	0	0	1	0	Pointer arrow Down

1, '2', '*', 'C'	0	0	1	1	Corner Down Right

1, '2', '*', 'D'	0	1	0	0	Pointer arrow Left

1, '2', '*', 'E'	0	1	0	1	Horizontal bar

1, '2', '*', 'F'	0	1	1	0	Corner Left Down

1, '2', '*', 'G'	0	1	1	1	T Down

1, '2', '*', 'H'	1	0	0	0	Pointer arrow Up

1, '2', '*', 'I'	1	0	0	1	Corner Up Right

1, '2', '*', 'J'	1	0	1	0	Vertical unbroken bar

1, '2', '*', 'K'	1	0	1	1	T Right

1, '2', '*', 'L'	1	1	0	0	Corner Up Left

1, '2', '*', 'M'	1	1	0	1	T Up

1, '2', '*', 'N'	1	1	1	0	T Left

1, '2', '*', 'O'	1	1	1	1	Cross



To draw a horizontally and vertically divided window:



	C- -G- -F

	|   |   |



	|   |   |

	K- -O- -N

	|   |   |



	|   |   |

	I- -M- -L



</pre><p>



<A NAME="usrdefch">

<b>User Defined Characters</b><p>



Finally, the screen driver may create user defined characters by the

following combination which specifies the rows on a 6x8 matrix: <p>



1, 138, '=', charcode, r0, r1, r2, r3, r4, r5, r6, r7 <p>



Note that the count of 10 is specified in numeric form with the top

bit set (138) as it will not fit in a single digit. If you use a smaller

count, the unspecified rows will be set to 0. This can be useful since

most system characters have a blank bottom row. The number 'charcode' is

the character code of the defined character and must be between 64 ('@')

and 127 (DEL) inclusive providing 64 user characters on an expanded machine.

On an unexpanded machine (ie. without 128K or more in slot 1) only 16 characters

can be defined without encroaching on the memory used for the PipeDream

map. Characters above the limit of 16, will have their definitions overwritten

by map information when PipeDream is used. If the map width is 64 pixels

or less then the full 64 user characters can be used. <p>



r0 to r7 are the numeric representations of the top to bottom rows of

the character, with the top bit set. Bit 5 is on the left edge of the character

and bit 0 the right. The standard characters have their left-hand rows

blank, so if the user-defined characters are to sit alongside them, they

should follow this convention. The characters coexist with the normal characters

with the same code. Doing "VDU charcode" will print the system character,

whereas the sequence: <p>



1, '2', '?', charcode <p>



will print the user defined one. For instance: <p>



10 VDU 1, 138, ASC"=", ASC"@", 155, 155, 128, 132, 132, 132, 145, 142,

128 20 VDU 1, ASC"2", ASC"?", ASC"@" <p>



will draw a little smiling face to the screen. <p>



<A NAME="dispattr">

<b>Display Attributes</b><p>



These combinations toggle various display modes of the current window

(applying to subsequently written characters):



<pre>

1, 'B'      Bold

1, 'C'      Cursor visible

1, 'F'      Flash

1, 'G'      Grey

1, 'L'      Caps Lock

1, 'R'      Reverse video

1, 'S'      Vertical scrolling

1, 'T'      Tiny font

1, 'U'      Underline

1, 'W'      Horizontal scrolling

</pre>



With vertical scrolling on, the window scrolls when the cursor tries to go outside of the window 

else the cursor wraps from top row to bottom row or vice versa. <p>



With horizontal scrolling on, the row scrolls between the left and right margins when the cursor 

tries to go outside of the window margins

else the cursor wraps from left column to right column or vice versa. <p>



Horizontal scrolling disables vertical scrolling. <p>



Rather than toggling these modes, they may be set or reset explicitly by

prefixing them with '+' (on) or '-' (off), and a count byte of two to indicate

that there are two parameters. For instance: <p>



1, '2', '+', 'B' <p>



sets bold on. When written in this form, modes may be combined in a

list, for example: <p>



1, '5', '-', 'B', 'F', 'T', 'U' <p>



resets the bold, flash, tiny, underline toggles. Finally SD_DTS ($7F)

deletes all toggle settings, ie. sets all toggles to off: <p>



1, SD_DTS <br>

&nbsp; <p>



<A NAME="attrchan">

<b>Changing Display Attributes</b><p>



The display modes are usually set at the time of writing text to the screen,

however it is possible to apply the various effects to text already present.

This approach is used in the menu system to highlight commands and by the

Filer to highlight files. The technique can only be used with the hardware

attributes ie. flash, grey, inverse and underline. The two commands, apply

and eor, work over the next &lt;n> characters where &lt;n> is the second

parameter and offset from 32:



<pre>

1, '2', 'A', 32+&lt;n>     Apply toggles

1, '2', 'E', 32+&lt;n>     EOR toggles

</pre>



The following sequence inverts a 20 character bar at cursor position (0,0): <p>



1, '2', '+', 'R', 1, '3', '@', 32, 32, 1, '2', 'E', 52 <p>



<A NAME="windows">

<b>Windows</b><p>



Windows on the Z88 are referred to by a single ASCII numeric character.

Windows '1' to '6' are available for the user to redefine; '7' and '8'

are already used by the system - window '7' is the topic area, window '8'

is used by many of the system calls during error processing. Windows remember

their toggle settings, but if the window area is overwritten (by text from

an overlapping window, for example) then the window contents are lost.

The following sequences manipulate the windows. The # character is used

because it is vaguely reminiscent of a window: <p>



<A NAME="windef">

<b>Defining a Window</b><p>



1, '7', '#', '&lt;n>', 32+x, 32+y, 32+w, 32+d, t <p>



The "type" of the window is defined by the parameter t:



<pre>

bit 0       sets left and right bars on

bit 1       sets shelf brackets on

bit 2 - 6   ignored

bit 7       must be set.

</pre>



The type parameter is optional. Using a count byte of '6' will define the

window without bars or brackets. 

The PipeDream map window actually has bit 5 and 6 set and not bit 7. <p>



This redefines window &lt;n>, with the top left corner at (x,y) and

horizontal and vertical sizes of w and d respectively. The values of x

and y are offset from the top left corner of the application area ie. (10,0),

but can be made absolute (ie. offset from the top left corner of the screen)

by using 128+x, 128+y in the above sequence. E.g. for placing a window at top 

left corner of the screen use relative coordinates 32-10,32-0, absolute 

coordinates 128+0, 128+0 or mixed 128+0,32+0. It is very important that windows

do not go beyond the width of the screen. To avoid the OZ window, windows

should be no more than 94 6 pixel wide characters from the edge of the

application window, or 104 from the leftmost edge of the screen. <p>



Application windows may be preserved by using the system call <a href='ossr.htm'>OS_Sr</a>,

A=SR_SUS. This is a lazy method and consumes 2K of contigous memory - don't

use use it unless strictly necessary. Further, only the screen area starting

from (10,0) to the right edge (before the OZ window) are preserved. Windows

beyond that has to be redrawn explicitly. In any case, application windows

must be redrawn when your application is re-entered (otherwise your are

faced with a blank screen). If your application uses a window that overlaps

the system's topic window you must also re-draw your window after an executed

command, pressing &lt;MENU> or the &lt;HELP> key. <p>



The OZ window contains special characters which control the LCD scanning

and if these are disturbed, the display will not work properly. If your

window overlaps the OZ area, these characters are almost certain to be

disturbed. <p>



<A NAME="winsel">

<b>Selecting a Window</b><p>



To direct output to a window use one of the three following sequences:



<pre>

1, '2', 'H', '&lt;n>'	(Select and Hold)

1, '2', 'I', '&lt;n>'	(Select and Init)

1, '2', 'C', '&lt;n>'	(Select and Clear)

</pre>



The 'H' version will maintain display modes, whereas the 'I' version

will reset them all (ie. cursor off, scrolling disabled). If this is the

first time the window has been selected (after being redefined) then the

'I' version will also clear the window. The 'C' version resets the display

modes and clears the window. <p>



<A NAME="windel">

<b>Deleting a Window</b><p>



The following sequence clears a window including side bars and shelf brackets:



<pre>

1, '2', 'D', '&lt;n>'	(Delete/Destroy)

</pre><p>



<A NAME="winscrol">

<b>Window Scrolling</b>



<pre>

1, SD_DWN ($FE)                      Scroll downwards

1, SD_UP  ($FF)                      Scroll upwards

</pre>



Scrolling downwards is the usual direction. These commands operate over

the current window, not the screen. <p>



<A NAME="wingrey">

<b>Grey Window</b>



<pre>

1, '2', 'G', '+'                    Grey window

1, '2', 'G', '-'                    Ungrey window

</pre>



Please note that if you grey a window that has already been greyed then

ungreying doesn't work. <p>



<A NAME="winex">

<b>Bannered Window Example</b><p>



The shelf brackets are used by the system to create banners at the top

of a window (see the Filer display for an example). This effect is achieved

by using inverted, tiny and underlined characters. We give here an example

in BBC BASIC. You can enter this program on the Z88 and see the effect

of a bannered window. It is worth modifying the program to gain a feel

for the way the various screen effects work and how they are accessed by

the screen driver:

<p><tt>10 VDU 1, ASC"7", ASC"#", ASC"1", 33, 32, 72, 40, 131</tt>

<br><tt>20 VDU 1, ASC"2", ASC"I", ASC"1"</tt>

<br><tt>30 VDU 1, ASC"4", ASC"+", ASC"T", ASC"U", ASC"R", 1, ASC"2", ASC"J",

ASC"C"</tt>

<br><tt>40 PRINT TAB(0,0);"CENTRAL BANNER"; TAB(0,0;</tt>

<br><tt>50 VDU 1, ASC"2", ASC"A", 72</tt>

<br><tt>60 VDU 1, ASC"7", ASC"#", ASC"1", 33, 33, 39, 129</tt>

<br><tt>70 VDU 1, ASC"2", ASC"I", ASC"1"</tt>

<br><tt>80 VDU 1, ASC"3", ASC"+", ASC"C", ASC"S"</tt>

<p>Note how the window is defined one character in from the edge of the

screen to allow space for the vertical bar. It is then redefined to exclude

the top line of the screen, thus the banner will be undisturbed by text

written to the window. The centralization is achieved by using the justification

codes, which are as follows: <p>



<A NAME="justmarg">

<b>Justification and Margins</b><p>



<pre>

1, '2', 'J', 'N'        Normal

1, '2', 'J', 'C'        Centre

1, '2', 'J', 'L'        Left align

1, '2', 'J', 'R'        Right align

1, 'L', 32+n            Set left margin  (n=leftmost character position)

1, 'R', 32+n            Set right margin (n=rightmost character position)

</pre>



The default is 'normal'. Note that there is no count byte for the left

and right margin commands. The non-normal justification modes only work

with directly output text, in particular the system input routine fails

spectacularly if it is used with these modes. It is also worth noting that

if you output more characters than will fit between the margins then horisontal

scrolling, and not wrapping, will occur. <p>



<A NAME="cursorto">

<b>Cursor Positioning</b><p>



The cursor position, ie. the next print position, may be moved by the

following sequences - x and y are the column and row respectively, with

(0,0) being the top left of the current window:



<pre>

1, '3', '@', 32+x, 32+y             move to x,y

1, '2', 'X', 32+x                   horisontal tab

1, '2', 'Y', 32+y                   vertical tab

</pre><p>



<A NAME="clsfcur">

<b>Clear from Cursor</b>



<pre>

1, '2', 'C', 253                    Clear from the cursor to the end of the line.

1, '2', 'C', 254                    Clear from the cursor to the end of the window.

</pre>



<A NAME="multout">

<b>Multiple Output</b>



<pre>

1, '3', 'N', 32+n, m                Output n copies of the code m

</pre>



<A NAME="multbell">

<b>Multiple Bell</b>



<pre>

1, '4', '!', 32+r, 32+s, 32+m       Beep sequence

</pre>



A beep sequence is a series of beeps

(NOT a single beep), with mark m and space s (in 10ms ticks), and r cycles. <p>



<A NAME="unknown">

<b>Unknown</b>



<pre>

1, '2', '.', '['                    Unknown (Possibly used by the system

1, '2', '.', ']'                    for control of screen restoring.)

</pre><p>



<A NAME="lowlev">

<b>Low Level Access</b><p>



There are three calls which can be used to obtain information about

the current state of the screen and they are all accessed via <a href='osnq.htm'>OS_Nq</a> which

takes a reason code in the BC register. A fuller description is given in

"Miscellaneous useful routines", but the reason codes of interest are:



<pre>

NQ_WBOX     return the size of a window

NQ_WCUR     return the cursor location in a window and indicate whether enabled

NQ_RDS      read characters from the screen starting at the cursor position

</pre><p>



<hr WIDTH="100%">

<table BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%">

<tr>

<td ALIGN=LEFT VALIGN=TOP WIDTH="33%"><a href="memmanag.htm">Previous</a></td>

<td ALIGN=CENTER VALIGN=TOP WIDTH="34%"><a href="index.htm">Contents</a></td>

<td ALIGN=RIGHT VALIGN=TOP WIDTH="33%"><a href="fileio.htm">Next</a></td>

</tr>

<tr>

<td ALIGN=LEFT VALIGN=TOP WIDTH="33%">Memory Management</td>

<td ALIGN=CENTER VALIGN=TOP WIDTH="34%">Output and the screen driver</td>

<td ALIGN=RIGHT VALIGN=TOP WIDTH="33%">File Input / Output</td>

</tr>

</table>



</body>

</html>


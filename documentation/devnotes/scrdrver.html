<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Output and the screen driver</title>
<link href="stylesheet.css" type="text/css" rel="stylesheet" />

</head>

<body>

<table style="font-size: 12px" border="0" cellpadding="0" cellspacing="0" width="100%">
 <tr>
  <th colspan="3">Z88 Developers' Notes</th>
 </tr>
 <tr>
  <td valign="bottom" width="10%"><a href="memmanag.html">Previous</a></td>
  <td align="center" valign="bottom" width="80%"><a
  href="index.html">Contents</a></td>
  <td align="right" valign="bottom" width="10%"><a
  href="fileio.html">Next</a></td>
 </tr>
</table>

<hr>

<p><font size="4"><b>7. Output and the screen driver</b></font> <br>
&nbsp;</p>

<p><a name="output"><b>Output</b></a></p>

<p><a name="output">Output to the screen can be achieved by
treating the screen as a device and using the file I/O system
calls. However, there are four calls which can be used to send
output to what is called standard output, which although it may
be redefined by the CLI, see 'Standard I/O and the CLI', is
usually the screen device. The four calls are: </a></p>

<pre><a name="output">
   </a><a href="osout.html">OS_Out</a>   write character to standard output
   <a href="gnnln.html">GN_Nln</a>   write newline to standard output (&lt;CR&gt;&lt;LF&gt;)
   <a href="gnsop.html">GN_Sop</a>   write a string in local memory to standard output
   <a href="gnsoe.html">GN_Soe</a>   as <a
href="gnsop.html">GN_Sop</a>, but from an extended address
</pre>

<p>These calls are fairly friendly as far as register corruption
is concerned. <a href="osout.html">OS_Out</a> writes the character
held in register A and forces Fc = 0 before returning with no
other register or flag changes. <a href="gnnln.html">GN_Nln</a>
changes no registers and returns Fc = 0 unless there is an error.
<a href="gnsop.html">GN_Sop</a> and <a href="gnsoe.html">GN_Soe</a>
expect HL (or BHL) to point to a null-terminated string, and on
exit HL (or BHL) will point to the null, with other registers
remaining the same, unless there is an error. Errors can occur if
the standard output device has been redirected to somewhere other
than the screen. In the case of errors Fc = 1 and register A will
contain an error code. If you are not doing any redirection
yourself then these kind of error situations can be largely
ignored, since if the user is doing bizarre stream rebindings it
is not your responsibility what happens. Examples of these
routines in use can be seen in the &quot;Input and the keyboard
decoder&quot; section. </p>

<p>In using the Z88 you may well have come across a &quot;Page
Wait&quot; message which appears on the left hand side of the
screen in place of the application name and list of topics. This
message can be generated by an application (it is not done
automatically) when scrolling output is being sent to the screen.
The actual system call involved is <a href="ossr.html">OS_Sr</a>
with register A = SR_PWT. This call produces the &quot;Page
Wait&quot; message, waits for a key, restores the application
name and topic list and then returns to the application. Because
at the core of this routine there is a keyread, application
writers must be careful to check for pre-emption codes,
especially RC_QUIT. Although the writer may think about
&quot;Page Wait&quot; as primarily an output function, it has all
the characteristics of an input function. However, it only
returns &lt;BACKSPACE&gt; (ASCII 8) and all relevant error codes
like RC_QUIT and RC_DRAW. <br>
&nbsp;</p>

<p><a name="scrdrv"><b>The screen driver</b></a></p>

<p><a name="scrdrv">The Z88 incorporates a comprehensive screen
driver, so that apart from printing normal characters, the user
may, by sending suitable control codes to the screen: </a></p>

<pre><a name="scrdrv">
   Set fonts and select bold or flash effects for characters;
   Switch the cursor on and off;
   Simulate the effects of special keys (Caps lock, index etc.)
   Define, select and scroll windows;
   Select the horisontal and vertical print positions;
   Set justification or alignment;
   Set up user defined characters;
   Make various strings of beeps
</a></pre>

<p><a name="scrdrv">in fact, any graphic effects used by the
built-in software with the single exception of the map. This is
accessed more directly through the system calls, in particular </a><a
href="osmap.html">OS_Map</a> described in &quot;Miscellaneous
useful routines&quot;. The Standard library have also supplied utilities to
plot, draw lines and sprites in the map area, which easily can be
linked with application code using the Z80 Module Assembler Mpm. </p>

<p><a name="ctrlchar"><b>Direct Control Characters</b></a></p>

<a name="ctrlchar">The following standard control characters
have a special effect: </a>

<pre><a name="ctrlchar">
<i>ASCII name</i>  <i>Value</i>    <i>Z88 effect</i>
NUL         $00      Ignored (Possibly used by the system for control of screen restoring.)
SOH         $01      Escape character for screen driver
ENQ         $05      Escape character for printer filter
BEL         $07      Make a beep
BS          $08      Move Cursor Left
HT          $09      Move Cursor Right
LF          $0A      Move Cursor Down
VT          $0B      Move Cursor Up
FF          $0C      Clear screen (current window)
DEL         $7F      Draw black box, (currently, undefined codes do too)
</a></pre>

<p><a name="escseq"><b>Escape Sequences</b></a></p>

<p><a name="escseq">The characters SOH ($01) is used as an escape
character to prefix the special character combinations. It may be
followed either by a single special character, or if more than
one parameter is to follow, by a count byte which specifies the
number of following parameters - this may be in the form of a
binary number with the top bit set, ie. count plus 128, or an
ASCII code for a single decimal digit - clearly the latter is
impossible for a count of more than 9. Thus the following
sequences are equivalent - both move the cursor to character
position (x,y): </a></p>

<p><a name="escseq">1, '3', '@', 32+x, 32+y 1, 128+3, '@', 32+x,
32+y </a></p>

<p><a name="escseq">NOTE: A character in single quotes is used in
this section as a concise notation for a character constant, so
for instance 'A' is the ASCII code for A, ie. $41 or 65 decimal.
This translates into rather less elegant ASC&quot;A&quot; when
used in BBC BASIC or its assembler, so to send the former of the
above sequences to the screen from BBC BASIC one might do: </a></p>

<p><a name="escseq">x=3: y=4 VDU 1,ASC&quot;3&quot;,
ASC&quot;@&quot;, 32+x,32+y</a></p>

<p><a name="specchar"><b>Special Characters</b></a></p>

<p><a name="specchar">The following screen driver codes generate
special printable characters when preceeded by SOH: </a></p>

<pre><a name="specchar">
<i>Code</i>     <i>Value</i>    <i>Description</i>    <i>Width</i>  <i>Boldable</i>
' '   $20   Exact symbol   1
'!'   $21   Bell symbol    3
'''   $27   Grave accent   1   yes
'*'   $2A   Square     1   yes
'+'   $2B   Diamond     1   yes
'-'   $2D   SHIFT symbol   3
'|'   $7D   Vertical unbroken bar 1   yes
SD_SPC  $E0   SPACE symbol   3
SD_ENT  $E1   ENTER symbol   3
SD_TAB  $E2   TAB symbol    3
SD_DEL  $E3   DEL symbol    3
SD_ESC  $E4   ESC symbol    3
SD_MNU  $E5   MENU symbol    3
SD_INX  $E6   INDEX symbol   3
SD_HLP  $E7   HELP symbol    3
SD_OLFT  $F0   Outline arrow Left  2
SD_ORGT  $F1   Outline arrow Right  2
SD_ODWN  $F2   Outline arrow Down  2
SD_OUP  $F3   Outline arrow Up  2
SD_BLFT  $F4   Bullet arrow Left  1
SD_BRGT  $F5   Bullet arrow Right  1
SD_BDWN  $F6   Bullet arrow Down  1
SD_BUP  $F7   Bullet arrow Up   1
SD_PLFT  $F8   Pointer arrow Left  1   yes
SD_PRGT  $F9   Pointer arrow Right  1   yes
SD_PDWN  $FA   Pointer arrow Down  1   yes
SD_PUP  $FB   Pointer arrow Up  1   yes
</a></pre>

<p><a name="boxchars"><b>Box Characters</b></a></p>

<p><a name="boxchars">1, '2', '*', &lt;char&gt; </a></p>

<p><a name="boxchars">(where &lt;char&gt; is from 'A' to 'O')
draws various character such as arrows or box construction shapes
(which are all boldable), with the following logic: </a></p>

<p><a name="boxchars">Each of the bottom 4 bits of 'char'
represents a direction: </a></p>

<pre><a name="boxchars">
bit 0  decimal 1 Left
bit 1  decimal 2 Down
bit 2  decimal 4 Right
bit 3  decimal 8 Up
</a></pre>

<p><a name="boxchars">If one bit is set, a pointer arrow in the
relevant direction is drawn. If two bits are set, two sides of a
square or a line will be drawn. If three bits are set, a 'T'
shape will be drawn. If all four bits are set, a cross will be
drawn. </a></p>

<p><a name="boxchars">For example, the corner generated: VDU 1,
ASC&quot;2&quot;, ASC&quot;*&quot;, ASC&quot;F&quot; makes a
reasonable logical NOT sign. <br>
&nbsp; </a></p>

<pre><a name="boxchars">
Code   Up Left Down Right Symbol

1, '2', '*', 'A' 0 0 0 1 Pointer arrow Right
1, '2', '*', 'B' 0 0 1 0 Pointer arrow Down
1, '2', '*', 'C' 0 0 1 1 Corner Down Right
1, '2', '*', 'D' 0 1 0 0 Pointer arrow Left
1, '2', '*', 'E' 0 1 0 1 Horizontal bar
1, '2', '*', 'F' 0 1 1 0 Corner Left Down
1, '2', '*', 'G' 0 1 1 1 T Down
1, '2', '*', 'H' 1 0 0 0 Pointer arrow Up
1, '2', '*', 'I' 1 0 0 1 Corner Up Right
1, '2', '*', 'J' 1 0 1 0 Vertical unbroken bar
1, '2', '*', 'K' 1 0 1 1 T Right
1, '2', '*', 'L' 1 1 0 0 Corner Up Left
1, '2', '*', 'M' 1 1 0 1 T Up
1, '2', '*', 'N' 1 1 1 0 T Left
1, '2', '*', 'O' 1 1 1 1 Cross

To draw a horizontally and vertically divided window:

 C- -G- -F
 | | |

 | | |
 K- -O- -N
 | | |

 | | |
 I- -M- -L

</a></pre>

<p><a name="usrdefch"><b>User Defined Characters</b></a></p>

<p><a name="usrdefch">Finally, the screen driver may create user
defined characters by the following combination which specifies
the rows on a 6x8 matrix: </a></p>

<p><a name="usrdefch">1, 138, '=', charcode, r0, r1, r2, r3, r4,
r5, r6, r7 </a></p>

<p><a name="usrdefch">Note that the count of 10 is specified in
numeric form with the top bit set (138) as it will not fit in a
single digit. If you use a smaller count, the unspecified rows
will be set to 0. This can be useful since most system characters
have a blank bottom row. The number 'charcode' is the character
code of the defined character and must be between 64 ('@') and
127 (DEL) inclusive providing 64 user characters on an expanded
machine. On an unexpanded machine (ie. without 128K or more in
slot 1) only 16 characters can be defined without encroaching on
the memory used for the PipeDream map. Characters above the limit
of 16, will have their definitions overwritten by map information
when PipeDream is used. If the map width is 64 pixels or less
then the full 64 user characters can be used. </a></p>

<p><a name="usrdefch">r0 to r7 are the numeric representations of
the top to bottom rows of the character, with the top bit set.
Bit 5 is on the left edge of the character and bit 0 the right.
The standard characters have their left-hand rows blank, so if
the user-defined characters are to sit alongside them, they
should follow this convention. The characters coexist with the
normal characters with the same code. Doing &quot;VDU
charcode&quot; will print the system character, whereas the
sequence: </a></p>

<p><a name="usrdefch">1, '2', '?', charcode </a></p>

<p><a name="usrdefch">will print the user defined one. For
instance: </a></p>

<p><a name="usrdefch">10 VDU 1, 138, ASC&quot;=&quot;,
ASC&quot;@&quot;, 155, 155, 128, 132, 132, 132, 145, 142, 128 20
VDU 1, ASC&quot;2&quot;, ASC&quot;?&quot;, ASC&quot;@&quot; </a></p>

<p><a name="usrdefch">will draw a little smiling face to the
screen. </a></p>

<p><a name="dispattr"><b>Display Attributes</b></a></p>

<p><a name="dispattr">These combinations toggle various display
modes of the current window (applying to subsequently written
characters): </a></p>

<pre><a name="dispattr">
1, 'B'  Bold
1, 'C'  Cursor visible
1, 'F'  Flash
1, 'G'  Grey
1, 'L'  Caps Lock
1, 'R'  Reverse video
1, 'S'  Vertical scrolling
1, 'T'  Tiny font
1, 'U'  Underline
1, 'W'  Horizontal scrolling
</a></pre>

<p><a name="dispattr">With vertical scrolling on, the window
scrolls when the cursor tries to go outside of the window else
the cursor wraps from top row to bottom row or vice versa. </a></p>

<p><a name="dispattr">With horizontal scrolling on, the row
scrolls between the left and right margins when the cursor tries
to go outside of the window margins else the cursor wraps from
left column to right column or vice versa. </a></p>

<p><a name="dispattr">Horizontal scrolling disables vertical
scrolling. </a></p>

<p><a name="dispattr">Rather than toggling these modes, they may
be set or reset explicitly by prefixing them with '+' (on) or '-'
(off), and a count byte of two to indicate that there are two
parameters. For instance: </a></p>

<p><a name="dispattr">1, '2', '+', 'B' </a></p>

<p><a name="dispattr">sets bold on. When written in this form,
modes may be combined in a list, for example: </a></p>

<p><a name="dispattr">1, '5', '-', 'B', 'F', 'T', 'U' </a></p>

<p><a name="dispattr">resets the bold, flash, tiny, underline
toggles. Finally SD_DTS ($7F) deletes all toggle settings, ie.
sets all toggles to off: </a></p>

<p><a name="dispattr">1, SD_DTS <br>
&nbsp; </a></p>

<p><a name="attrchan"><b>Changing Display Attributes</b></a></p>

<p><a name="attrchan">The display modes are usually set at the
time of writing text to the screen, however it is possible to
apply the various effects to text already present. This approach
is used in the menu system to highlight commands and by the Filer
to highlight files. The technique can only be used with the
hardware attributes ie. flash, grey, inverse and underline. The
two commands, apply and eor, work over the next &lt;n&gt;
characters where &lt;n&gt; is the second parameter and offset
from 32: </a></p>

<pre><a name="attrchan">
1, '2', 'A', 32+&lt;n&gt;   Apply toggles
1, '2', 'E', 32+&lt;n&gt;   EOR toggles
</a></pre>

<p><a name="attrchan">The following sequence inverts a 20
character bar at cursor position (0,0): </a></p>

<p><a name="attrchan">1, '2', '+', 'R', 1, '3', '@', 32, 32, 1,
'2', 'E', 52 </a></p>

<p><a name="windows"><b>Windows</b></a></p>

<p><a name="windows">Windows on the Z88 are referred to by a
single ASCII numeric character. Windows '1' to '6' are available
for the user to redefine; '7' and '8' are already used by the
system - window '7' is the topic area, window '8' is used by many
of the system calls during error processing. Windows remember
their toggle settings, but if the window area is overwritten (by
text from an overlapping window, for example) then the window
contents are lost. The following sequences manipulate the
windows. The # character is used because it is vaguely
reminiscent of a window: </a></p>

<p><a name="windef"><b>Defining a Window</b></a></p>

<p><a name="windef">1, '7', '#', '&lt;n&gt;', 32+x, 32+y, 32+w,
32+d, t </a></p>

<p><a name="windef">The &quot;type&quot; of the window is defined
by the parameter t: </a></p>

<pre><a name="windef">
bit 0  sets left and right bars on
bit 1  sets shelf brackets on
bit 2 - 6 ignored
bit 7  must be set.
</a></pre>

<p><a name="windef">The type parameter is optional. Using a count
byte of '6' will define the window without bars or brackets. The
PipeDream map window actually has bit 5 and 6 set and not bit 7. </a></p>

<p><a name="windef">This redefines window &lt;n&gt;, with the top
left corner at (x,y) and horizontal and vertical sizes of w and d
respectively. The values of x and y are offset from the top left
corner of the application area ie. (10,0), but can be made
absolute (ie. offset from the top left corner of the screen) by
using 128+x, 128+y in the above sequence. E.g. for placing a
window at top left corner of the screen use relative coordinates
32-10,32-0, absolute coordinates 128+0, 128+0 or mixed
128+0,32+0. It is very important that windows do not go beyond
the width of the screen. To avoid the OZ window, windows should
be no more than 94 6 pixel wide characters from the edge of the
application window, or 104 from the leftmost edge of the screen. </a></p>

<p><a name="windef">Application windows may be preserved by using
the system call </a><a href="ossr.html">OS_Sr</a>, A=SR_SUS. This
is a lazy method and consumes 2K of continuous memory - don't use
use it unless strictly necessary. Further, only the screen area
starting from (10,0) to the right edge (before the OZ window) are
preserved. Windows beyond that has to be redrawn explicitly. In
any case, application windows must be redrawn when your
application is re-entered (otherwise your are faced with a blank
screen). If your application uses a window that overlaps the
system's topic window you must also re-draw your window after an
executed command, pressing &lt;MENU&gt; or the &lt;HELP&gt; key. </p>

<p>The OZ window contains special characters which control the
LCD scanning and if these are disturbed, the display will not
work properly. If your window overlaps the OZ area, these
characters are almost certain to be disturbed. </p>

<p><a name="winsel"><b>Selecting a Window</b></a></p>

<p><a name="winsel">To direct output to a window use one of the
three following sequences: </a></p>

<pre><a name="winsel">
1, '2', 'H', '&lt;n&gt;' (Select and Hold)
1, '2', 'I', '&lt;n&gt;' (Select and Init)
1, '2', 'C', '&lt;n&gt;' (Select and Clear)
</a></pre>

<p><a name="winsel">The 'H' version will maintain display modes,
whereas the 'I' version will reset them all (ie. cursor off,
scrolling disabled). If this is the first time the window has
been selected (after being redefined) then the 'I' version will
also clear the window. The 'C' version resets the display modes
and clears the window. </a></p>

<p><a name="windel"><b>Deleting a Window</b></a></p>

<p><a name="windel">The following sequence clears a window
including side bars and shelf brackets: </a></p>

<pre><a name="windel">
1, '2', 'D', '&lt;n&gt;' (Delete/Destroy)
</a></pre>

<p><a name="winscrol"><b>Window Scrolling</b> </a></p>

<pre><a name="winscrol">
1, SD_DWN ($FE)       Scroll downwards
1, SD_UP  ($FF)       Scroll upwards
</a></pre>

<p><a name="winscrol">Scrolling downwards is the usual direction.
These commands operate over the current window, not the screen. </a></p>

<p><a name="wingrey"><b>Grey Window</b> </a></p>

<pre><a name="wingrey">
1, '2', 'G', '+'     Grey window
1, '2', 'G', '-'     Ungrey window
</a></pre>

<p><a name="wingrey">Please note that if you grey a window that
has already been greyed then ungreying doesn't work. </a></p>

<p><a name="winex"><b>Bannered Window Example</b></a></p>

<p><a name="winex">The shelf brackets are used by the system to
create banners at the top of a window (see the Filer display for
an example). This effect is achieved by using inverted, tiny and
underlined characters. We give here an example in BBC BASIC. You
can enter this program on the Z88 and see the effect of a
bannered window. It is worth modifying the program to gain a feel
for the way the various screen effects work and how they are
accessed by the screen driver: </a></p>

<p><a name="winex"><tt>10 VDU 1, ASC&quot;7&quot;,
ASC&quot;#&quot;, ASC&quot;1&quot;, 33, 32, 72, 40, 131</tt> <br>
<tt>20 VDU 1, ASC&quot;2&quot;, ASC&quot;I&quot;,
ASC&quot;1&quot;</tt> <br>
<tt>30 VDU 1, ASC&quot;4&quot;, ASC&quot;+&quot;,
ASC&quot;T&quot;, ASC&quot;U&quot;, ASC&quot;R&quot;, 1,
ASC&quot;2&quot;, ASC&quot;J&quot;, ASC&quot;C&quot;</tt> <br>
<tt>40 PRINT TAB(0,0);&quot;CENTRAL BANNER&quot;; TAB(0,0;</tt> <br>
<tt>50 VDU 1, ASC&quot;2&quot;, ASC&quot;A&quot;, 72</tt> <br>
<tt>60 VDU 1, ASC&quot;7&quot;, ASC&quot;#&quot;,
ASC&quot;1&quot;, 33, 33, 39, 129</tt> <br>
<tt>70 VDU 1, ASC&quot;2&quot;, ASC&quot;I&quot;,
ASC&quot;1&quot;</tt> <br>
<tt>80 VDU 1, ASC&quot;3&quot;, ASC&quot;+&quot;,
ASC&quot;C&quot;, ASC&quot;S&quot;</tt> </a></p>

<p><a name="winex">Note how the window is defined one character
in from the edge of the screen to allow space for the vertical
bar. It is then redefined to exclude the top line of the screen,
thus the banner will be undisturbed by text written to the
window. The centralization is achieved by using the justification
codes, which are as follows: </a></p>

<p><a name="justmarg"><b>Justification and Margins</b></a></p>

<pre><a name="justmarg">
1, '2', 'J', 'N'  Normal
1, '2', 'J', 'C'  Centre
1, '2', 'J', 'L'  Left align
1, '2', 'J', 'R'  Right align
1, 'L', 32+n   Set left margin  (n=leftmost character position)
1, 'R', 32+n   Set right margin (n=rightmost character position)
</a></pre>

<p><a name="justmarg">The default is 'normal'. Note that there is
no count byte for the left and right margin commands. The
non-normal justification modes only work with directly output
text, in particular the system input routine fails spectacularly
if it is used with these modes. It is also worth noting that if
you output more characters than will fit between the margins then
horisontal scrolling, and not wrapping, will occur. </a></p>

<p><a name="cursorto"><b>Cursor Positioning</b></a></p>

<p><a name="cursorto">The cursor position, ie. the next print
position, may be moved by the following sequences - x and y are
the column and row respectively, with (0,0) being the top left of
the current window: </a></p>

<pre><a name="cursorto">
1, '3', '@', 32+x, 32+y    move to x,y
1, '2', 'X', 32+x     horisontal tab
1, '2', 'Y', 32+y     vertical tab
</a></pre>

<p><a name="clsfcur"><b>Clear from Cursor</b> </a></p>

<pre><a name="clsfcur">
1, '2', 'C', 253     Clear from the cursor to the end of the line.
1, '2', 'C', 254     Clear from the cursor to the end of the window.
</a></pre>

<p><a name="multout"><b>Multiple Output</b> </a></p>

<pre><a name="multout">
1, '3', 'N', 32+n, m    Output n copies of the code m
</a></pre>

<p><a name="multbell"><b>Multiple Bell</b> </a></p>

<pre><a name="multbell">
1, '4', '!', 32+r, 32+s, 32+m  Beep sequence
</a></pre>

<p><a name="multbell">A beep sequence is a series of beeps (NOT a
single beep), with mark m and space s (in 10ms ticks), and r
cycles. </a></p>

<p><a name="redirection"><b>Toggle redirection to printer</b></a></p>

<pre>
1, '2', '.', '['     Disable CLI redirection to printer
1, '2', '.', ']'     Enable CLI redirection to printer</pre>

<p>These sequence are used to avoid sending SOH sequence to the
printer when a CLI redirection to printer is active.</p>

<p><a name="lowlev"><b>Low Level Access</b></a></p>

<p><a name="lowlev">There are three calls which can be used to
obtain information about the current state of the screen and they
are all accessed via </a><a href="osnq.html">OS_Nq</a> which takes
a reason code in the BC register. A fuller description is given
in &quot;Miscellaneous useful routines&quot;, but the reason
codes of interest are: </p>

<pre>
NQ_WBOX  return the size of a window
NQ_WCUR  return the cursor location in a window and indicate whether enabled
NQ_RDS  read characters from the screen starting at the cursor position
</pre>

<hr>

<table style="font-size: 12px" border="0" cellpadding="0" cellspacing="0" width="100%">
 <tr>
  <td valign="top" width="33%"><a href="memmanag.html">Previous</a></td>
  <td align="center" valign="top" width="34%"><a
  href="index.html">Contents</a></td>
  <td align="right" valign="top" width="33%"><a
  href="fileio.html">Next</a></td>
 </tr>
 <tr>
  <td valign="top" width="33%">Memory Management</td>
  <td align="center" valign="top" width="34%">Output and
  the screen driver</td>
  <td align="right" valign="top" width="33%">File Input /
  Output</td>
 </tr>
</table>
</body>
</html>
